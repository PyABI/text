<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>The Text Layer</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="prev" href="the_unicode_layer/bidirectional_text.html" title="Bidirectional Text">
<link rel="next" href="performance_considerations.html" title="Performance Considerations">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="the_unicode_layer/bidirectional_text.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="performance_considerations.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_text__proposed_.the_text_layer"></a><a class="link" href="the_text_layer.html" title="The Text Layer">The Text Layer</a>
</h2></div></div></div>
<p>
      The text layer of Boost.Text consists mostly of four types: <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Struct text_view">text_view</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Struct rope">rope</a></code>, and <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Struct rope_view">rope_view</a></code>. These are directly
      analogous to their string layer counterparts <code class="computeroutput">std::string</code>,
      <code class="computeroutput">std::string_view</code>,
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>,
      and <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Struct unencoded_rope_view">unencoded_rope_view</a></code>,
      respectively. In fact, each of the text layer types has a single data member
      &#8212; an object of the corresponding string layer type.
    </p>
<p>
      Let's consider one of the text layer types in particular, <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code>. It's underlying storage
      is a <code class="computeroutput">std::string</code>,
      as mentioned before. The <code class="computeroutput"><span class="keyword">char</span></code>s
      in the <code class="computeroutput">std::string</code>
      are UTF-8 encoded. The code point view of those UTF-8 encoded <code class="computeroutput"><span class="keyword">char</span></code>s is available by using <code class="computeroutput"><a class="link" href="../boost/text/utf_8_to_32_iterator.html" title="Struct template utf_8_to_32_iterator">utf_8_to_32_iterator</a></code>. Since
      <code class="computeroutput"><a class="link" href="../boost/text/utf_8_to_32_iterator.html" title="Struct template utf_8_to_32_iterator">utf_8_to_32_iterator</a></code>
      generates replacement characters when it encounters a broken encoding, no runtime
      checks ever need to be performed on the encoding of the <code class="computeroutput"><span class="keyword">char</span></code>s
      in a <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code>'s
      <code class="computeroutput">std::string</code>
      data member.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        To be absolutely clear, all the text layer types use UTF-8 encoding. There
        are no other options. Transcoding to UTF-16 is still possible using <code class="computeroutput"><a class="link" href="../boost/text/utf_8_to_16_iterator.html" title="Struct template utf_8_to_16_iterator">utf_8_to_16_iterator</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/text/utf_16_to_8_iterator.html" title="Struct template utf_16_to_8_iterator">utf_16_to_8_iterator</a></code>.
      </p></td></tr>
</table></div>
<p>
      All the text layer types are kept in the FCC normalization form at all times.
      There is a runtime cost associated with normalizing text that is inserted into
      a text layer type.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        To be absolutely clear about this as well, there are no other encoding options
        for the text layer types. Normalization to the four official Unicode forms
        is still available using the Unicode layer normalization algorithms.
      </p></td></tr>
</table></div>
<p>
      The text layer types are centered around graphemes instead of <code class="computeroutput"><span class="keyword">char</span></code>s. Since graphemes are variable-length,
      this means that all indexing is done using iterators instead of integral indices;
      there is no random access to the graphemes in the text layer types.
    </p>
<h4>
<a name="boost_text__proposed_.the_text_layer.h0"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.graphemes"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.graphemes">Graphemes</a>
    </h4>
<p>
      When you dereference an iterator that you get from one of the text layer types,
      you get a <code class="computeroutput"><a class="link" href="../boost/text/grapheme_ref.html" title="Struct template grapheme_ref">grapheme_ref</a></code>.
      This is a non-owning range of code points that is known to be normalized FCC.
    </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span> <span class="special">=</span> <span class="string">"A bit of text."</span><span class="special">;</span>

<span class="comment">// grapheme_refs should be declared as values in range-based for loops, since</span>
<span class="comment">// they are small value types.</span>
<span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">grapheme</span> <span class="special">:</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">grapheme</span><span class="special">;</span> <span class="comment">// grapheme_ref is directly streamable.</span>
    <span class="comment">// grapheme_ref is also a code point range, of course</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">cp</span> <span class="special">:</span> <span class="identifier">grapheme</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Do something with code point cp here....</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
</pre>
<p>
    </p>
<p>
      If you want an owning set of code points that is known to be normalized FCC,
      you can construct a <code class="computeroutput"><a class="link" href="../boost/text/grapheme.html" title="Struct grapheme">grapheme</a></code>
      (either from a <code class="computeroutput"><a class="link" href="../boost/text/grapheme_ref.html" title="Struct template grapheme_ref">grapheme_ref</a></code>,
      or by some other means).
    </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// These functions don't do anything interesting; Just pay attention to the</span>
<span class="comment">// interfaces.</span>

<span class="comment">// This returns a view into a temporary.  Don't do this.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">grapheme_ref</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">::</span><span class="identifier">iterator_type</span><span class="special">&gt;</span>
<span class="identifier">find_first_dot_bad</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">grapheme</span> <span class="special">:</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">uint32_t</span> <span class="identifier">target</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span><span class="char">'.'</span><span class="special">};</span>
        <span class="comment">// Using the one from Boost.Algorithm, so we get the 4-param version</span>
        <span class="comment">// even if we're not using a C++14 compiler.</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">algorithm</span><span class="special">::</span><span class="identifier">equal</span><span class="special">(</span>
                <span class="identifier">grapheme</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">grapheme</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">target</span><span class="special">,</span> <span class="identifier">target</span> <span class="special">+</span> <span class="number">1</span><span class="special">))</span> <span class="special">{</span>
            <span class="comment">// This line compiles without warnings.  The compiler doesn't know</span>
            <span class="comment">// how to tell me I'm returning a dangling reference, because it's</span>
            <span class="comment">// a view, not a builtin reference.</span>
            <span class="keyword">return</span> <span class="identifier">grapheme</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">grapheme_ref</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">::</span><span class="identifier">iterator_type</span><span class="special">&gt;();</span>
<span class="special">}</span>

<span class="comment">// This returns a grapheme that owns its code point storage, so it cannot</span>
<span class="comment">// dangle.  Do this.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">grapheme</span> <span class="identifier">find_first_dot_good</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">grapheme</span> <span class="special">:</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">uint32_t</span> <span class="identifier">target</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span><span class="char">'.'</span><span class="special">};</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">algorithm</span><span class="special">::</span><span class="identifier">equal</span><span class="special">(</span>
                <span class="identifier">grapheme</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">grapheme</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">target</span><span class="special">,</span> <span class="identifier">target</span> <span class="special">+</span> <span class="number">1</span><span class="special">))</span> <span class="special">{</span>
            <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">grapheme</span><span class="special">(</span><span class="identifier">grapheme</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">grapheme</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        <code class="computeroutput"><a class="link" href="../boost/text/grapheme.html" title="Struct grapheme">grapheme</a></code>
        has a small-buffer optimization so that using it seldom involves allocations.
        This also implies that an array of <code class="computeroutput"><a class="link" href="../boost/text/grapheme.html" title="Struct grapheme">graphemes</a></code> is likely to be wasteful
        of storage. If you want a bunch of graphemes, you should probably be using
        a <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code>.
      </p></td></tr>
</table></div>
<p>
      An Individual grapheme, in the form of a <code class="computeroutput"><a class="link" href="../boost/text/grapheme.html" title="Struct grapheme">grapheme</a></code> or <code class="computeroutput"><a class="link" href="../boost/text/grapheme_ref.html" title="Struct template grapheme_ref">grapheme_ref</a></code>, can be inserted
      into a <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code>
      or <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Struct rope">rope</a></code>.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        The grapheme is the unit of work within the text layer. When using text layer
        types, you should always use the <a class="link" href="concepts.html#boost_text__proposed_.concepts.graphemerange">GraphemeRange</a>
        overloads of the Unicode algorithms.
      </p></td></tr>
</table></div>
<h4>
<a name="boost_text__proposed_.the_text_layer.h1"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.grapheme_iterators"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.grapheme_iterators">Grapheme
      Iterators</a>
    </h4>
<p>
      Since the grapheme is the unit of work within the text layer, it's natural
      that the text layer types return <code class="computeroutput"><a class="link" href="../boost/text/grapheme_iterator.html" title="Struct template grapheme_iterator">grapheme_iterators</a></code> from <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> and
      <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code>.
      But what about the times when you actually want to deal with sequences of code
      points or <code class="computeroutput"><span class="keyword">char</span></code>s? This comes up
      often when you need to use legacy interfaces.
    </p>
<p>
      Fortunately, that's really easy. <code class="computeroutput"><a class="link" href="../boost/text/grapheme_iterator.html" title="Struct template grapheme_iterator">grapheme_iterator</a></code> has a <code class="computeroutput"><span class="identifier">base</span><span class="special">()</span></code> member
      that returns its underlying code point iterator. The code point iterator used
      in the text layer types is always <code class="computeroutput"><a class="link" href="../boost/text/utf_8_to_32_iterator.html" title="Struct template utf_8_to_32_iterator">utf_8_to_32_iterator</a></code>, which also
      has a <code class="computeroutput"><span class="identifier">base</span><span class="special">()</span></code>
      member that returns <span class="emphasis"><em>it's</em></span> underlying <code class="computeroutput"><span class="keyword">char</span></code>
      iterator:
    </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// t is a GraphemeRange.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span> <span class="special">=</span> <span class="string">"This is a short sentence."</span><span class="special">;</span>

<span class="comment">// This is a code point range that contains all the same code points as t.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf32_view</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf_8_to_32_iterator</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*&gt;&gt;</span> <span class="identifier">cps</span><span class="special">(</span>
    <span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">().</span><span class="identifier">base</span><span class="special">(),</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">end</span><span class="special">().</span><span class="identifier">base</span><span class="special">());</span>

<span class="comment">// This is achar range that contains all the same code units as t, though it</span>
<span class="comment">// is not null-terminated like t's underlying storage is.</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">chars</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">().</span><span class="identifier">base</span><span class="special">().</span><span class="identifier">base</span><span class="special">(),</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">end</span><span class="special">().</span><span class="identifier">base</span><span class="special">().</span><span class="identifier">base</span><span class="special">());</span>
</pre>
<p>
    </p>
<p>
      if you remember from the discussion of the string layer types, <code class="computeroutput">std::string</code>
      is always null-terminated, and its iterator is just a <code class="computeroutput"><span class="keyword">char</span>
      <span class="special">*</span></code>. This means that any <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code> object <code class="computeroutput"><span class="identifier">t</span></code>
      is null-terminated too, as long as you access it's underlying <code class="computeroutput"><span class="keyword">char</span></code> iterator directly:
    </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span> <span class="special">=</span> <span class="string">"This is a short sentence."</span><span class="special">;</span>

<span class="identifier">assert</span><span class="special">(</span><span class="identifier">strlen</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">().</span><span class="identifier">base</span><span class="special">().</span><span class="identifier">base</span><span class="special">())</span> <span class="special">==</span> <span class="number">25</span><span class="special">);</span>

<span class="identifier">t</span> <span class="special">=</span> <span class="string">"This is a short s&#233;ance."</span><span class="special">;</span> <span class="comment">// &#233; occupies two UTF-8 code units.</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">strlen</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">().</span><span class="identifier">base</span><span class="special">().</span><span class="identifier">base</span><span class="special">())</span> <span class="special">==</span> <span class="number">24</span><span class="special">);</span>
</pre>
<p>
    </p>
<h4>
<a name="boost_text__proposed_.the_text_layer.h2"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.a_shortcoming"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.a_shortcoming">A
      Shortcoming</a>
    </h4>
<p>
      There is a problem with basing all your Unicode operations on graphemes. Graphemes
      do not always line up with the text segmentation algorithms. Specifically,
      lines are not guaranteed to end exactly on a grapheme break (the other text
      breaking algorithms all end on grapheme breaks).
    </p>
<p>
      There are two things to note here:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          The cases where a line does not end on a grapheme break are obscure corner
          cases that do not often come up in practice.
        </li>
<li class="listitem">
          Graphemes are context-sensitive. In other words, if you break a line in
          the middle of a grapheme <code class="computeroutput"><span class="identifier">G</span></code>,
          <code class="computeroutput"><span class="identifier">G</span></code>'s code points before
          the line break from their own grapheme, and the rest of <code class="computeroutput"><span class="identifier">G</span></code>'s
          code points form another grapheme. In other words, breaking graphemes is
          pretty benign; it's not like breaking encoding or normalization.
        </li>
</ol></div>
<h4>
<a name="boost_text__proposed_.the_text_layer.h3"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.the_text_layer_types"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.the_text_layer_types">The Text
      Layer Types</a>
    </h4>
<p>
      As mentioned before, this layer has four types (<code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Struct text_view">text_view</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Struct rope">rope</a></code>, and <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Struct rope_view">rope_view</a></code>) that are directly
      analogous to the four major types in the string layer (<code class="computeroutput">std::string</code>,
      <code class="computeroutput">std::string_view</code>,
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>,
      and <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Struct unencoded_rope_view">unencoded_rope_view</a></code>).
      The high-level semantics of these types is the same:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <code class="computeroutput">std::string</code>
          and <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code>
          are owning and contiguous.
        </li>
<li class="listitem">
          <code class="computeroutput">std::string_view</code>
          and <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Struct text_view">text_view</a></code>
          and non-owning and contiguous.
        </li>
<li class="listitem">
          <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
          and <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Struct rope">rope</a></code>
          are owning and discontiguous.
        </li>
<li class="listitem">
          <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Struct unencoded_rope_view">unencoded_rope_view</a></code>
          and <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Struct rope_view">rope_view</a></code>
          are non-owning and discontiguous.
        </li>
</ul></div>
<p>
      Other high-level semantics apply as well, such as the size-type used for each.
      How about the differences?
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          The text layer types are sequences of graphemes, not <code class="computeroutput"><span class="keyword">char</span></code>s.
        </li>
<li class="listitem">
          The text layer types are bidirectional ranges, not random-access ranges
          like the string layer types.
        </li>
<li class="listitem">
          There are no relational operators (<code class="computeroutput"><span class="special">&lt;</span></code>,
          <code class="computeroutput"><span class="special">&lt;=</span></code>, <code class="computeroutput"><span class="special">&gt;</span></code>,
          and <code class="computeroutput"><span class="special">&gt;=</span></code>). This is because
          this would lead to implicit ordering based on the type's binary representation,
          and not on some collation. This is wrong in some &#8212; but not all &#8212;
          contexts, making it bad candidate for implicit semantics.
        </li>
<li class="listitem">
          There are still equality comparison operators though (<code class="computeroutput"><span class="special">==</span></code>
          and <code class="computeroutput"><span class="special">!=</span></code>), because they are
          fundamental.
        </li>
<li class="listitem">
          There are no comparisons of any kind between the text layer types and the
          string layer types. This is because the former are all UTF-8 encoded and
          normalized, and the latter are not. Such comparisons across type should
          require explicit indication of the desired semantics.
        </li>
<li class="listitem">
          There are no <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>
          members. To implement this would be an <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span></code>
          operation, and so <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> would be a very misleading name for this.
          There is instead a <code class="computeroutput"><span class="identifier">distance</span><span class="special">()</span></code> function that returns the number of graphemes
          in <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span></code> time.
          There is an <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="number">1</span><span class="special">)</span></code> member
          <code class="computeroutput"><span class="identifier">storage_bytes</span><span class="special">()</span></code>
          that returns the size (in <code class="computeroutput"><span class="keyword">char</span></code>s)
          of the underlying storage.
        </li>
<li class="listitem">
          Since it would imply a maximum number of graphemes, there is no <code class="computeroutput"><span class="identifier">max_size</span><span class="special">()</span></code>
          either. There is instead a <code class="computeroutput"><span class="identifier">max_bytes</span><span class="special">()</span></code>.
        </li>
<li class="listitem">
          <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code>
          has a <code class="computeroutput"><span class="identifier">capacity_bytes</span><span class="special">()</span></code>
          instead of a <code class="computeroutput"><span class="identifier">capacity</span><span class="special">()</span></code>
          member.
        </li>
<li class="listitem">
          There are two members that allow you to steal and/or replace the underlying
          storage of the owning text layer types (<code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code> and <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Struct rope">rope</a></code>). <code class="computeroutput"><span class="identifier">extract</span><span class="special">()</span></code> moves the underlying container out, and
          an overload of <code class="computeroutput"><span class="identifier">replace</span><span class="special">()</span></code> moves it in. <code class="computeroutput"><span class="identifier">replace</span><span class="special">()</span></code> requires the moved-in container is normalized
          FCC.
        </li>
</ul></div>
<p>
      If you want to know which text layer type to use, you can refer back to the
      handy table in the string layer documentation. The text layer types have the
      same relationships among each other that the string layer types do among themselves.
    </p>
<h4>
<a name="boost_text__proposed_.the_text_layer.h4"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.an_odd_thing_about_insertions"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.an_odd_thing_about_insertions">An
      Odd Thing About Insertions</a>
    </h4>
<p>
      When you insert into a <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code>
      or <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Struct rope">rope</a></code>,
      you get back an iterator that points to the copy of the beginning of the inserted
      text. This is what the standard C++ containers do too.
    </p>
<p>
      So, if I insert, I get an iterator that points to the start of the insertion:
    </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">rope</span> <span class="identifier">r</span><span class="special">(</span><span class="string">"e"</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">r</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">r</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="char">'f'</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">r</span><span class="special">.</span><span class="identifier">distance</span><span class="special">()</span> <span class="special">==</span> <span class="number">2</span><span class="special">);</span>           <span class="comment">// We added a grapheme.</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">it</span> <span class="special">==</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">next</span><span class="special">(</span><span class="identifier">r</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()));</span>  <span class="comment">// This one, in fact.</span>
</pre>
<p>
      Not so fast. If I insert a sequence starting with one or more combining code
      points, the beginning of the insertion might get combined with the preceding
      code point (due to FCC normalization) or grapheme (because combining marks
      at the end of a grapheme are just part of that grapheme):
    </p>
<pre class="programlisting"><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span> <span class="identifier">combining_diaeresis</span> <span class="special">=</span> <span class="identifier">u8</span><span class="string">"\u0308"</span><span class="special">;</span>
<span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span><span class="special">(</span><span class="string">"e"</span><span class="special">);</span>

<span class="keyword">auto</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">combining_diaeresis</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">distance</span><span class="special">()</span> <span class="special">==</span> <span class="number">1</span><span class="special">);</span>    <span class="comment">// No new grapheme!  We now have the single code point '&#235;'.</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">it</span> <span class="special">==</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());</span>

<span class="identifier">it</span> <span class="special">=</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">combining_diaeresis</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">distance</span><span class="special">()</span> <span class="special">==</span> <span class="number">1</span><span class="special">);</span>    <span class="comment">// Still no new grapheme.  We now have a grapheme with the code points '&#235;' and '&#168;'.</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">it</span> <span class="special">==</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());</span>
</pre>
<p>
      This behavior is correct, but a bit surprising when you first see it.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2018 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="the_unicode_layer/bidirectional_text.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="performance_considerations.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
