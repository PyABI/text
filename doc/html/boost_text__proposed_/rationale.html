<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Rationale</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="prev" href="../index/s17.html" title="Macro Index">
<link rel="next" href="unicode_copyright_notice.html" title="Unicode Copyright Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../index/s17.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="unicode_copyright_notice.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_text__proposed_.rationale"></a><a class="link" href="rationale.html" title="Rationale">Rationale</a>
</h2></div></div></div>
<h4>
<a name="boost_text__proposed_.rationale.h0"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.size_and_index_types"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.size_and_index_types">Size
      and Index Types</a>
    </h4>
<p>
      Signed values as sizes are advantageous for a number of reasons:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          When doing math with sizes, intermediate values can be negative (which
          makes sense), instead of wrapping around to a very large value (which does
          not).
        </li>
<li class="listitem">
          Optimizers produce better code generation in more situations for signed
          values.
        </li>
<li class="listitem">
          Signed values lead naturally to the negative-indexable slicing that Boost.Text
          uses.
        </li>
</ol></div>
<p>
      This last point is particularly important. I think that negative indexing should
      be allowed on all random access ranges.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h1"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale._code__phrase_role__keyword__char__phrase___phrase_role__keyword__const__phrase___phrase_role__special_____phrase___code__iterators"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale._code__phrase_role__keyword__char__phrase___phrase_role__keyword__const__phrase___phrase_role__special_____phrase___code__iterators"><code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span></code> Iterators</a>
    </h4>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/v1/string.html" title="Struct string">string</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/text/v1/string_view.html" title="Struct string_view">string_view</a></code>
      both use <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
      <span class="special">*</span></code> as their forward iterator types. This
      allows interoperability with C strings and arrays of <code class="computeroutput"><span class="keyword">char</span></code>.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h2"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.where_are__code__phrase_role__identifier__data__phrase__phrase_role__special______phrase___code____code__phrase_role__identifier__c_str__phrase__phrase_role__special______phrase___code____code__phrase_role__identifier__front__phrase__phrase_role__special______phrase___code___and__code__phrase_role__identifier__back__phrase__phrase_role__special______phrase___code__"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.where_are__code__phrase_role__identifier__data__phrase__phrase_role__special______phrase___code____code__phrase_role__identifier__c_str__phrase__phrase_role__special______phrase___code____code__phrase_role__identifier__front__phrase__phrase_role__special______phrase___code___and__code__phrase_role__identifier__back__phrase__phrase_role__special______phrase___code__">Where
      Are <code class="computeroutput"><span class="identifier">data</span><span class="special">()</span></code>,
      <code class="computeroutput"><span class="identifier">c_str</span><span class="special">()</span></code>,
      <code class="computeroutput"><span class="identifier">front</span><span class="special">()</span></code>,
      and <code class="computeroutput"><span class="identifier">back</span><span class="special">()</span></code>?</a>
    </h4>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/v1/string.html" title="Struct string">string</a></code>
      does not have any of these, even though <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
      does. Since <code class="computeroutput"><span class="identifier">string</span><span class="special">::</span><span class="identifier">iterator</span></code> is just <code class="computeroutput"><span class="keyword">char</span>
      <span class="keyword">const</span> <span class="special">*</span></code>,
      and <code class="computeroutput"><a class="link" href="../boost/text/v1/string.html" title="Struct string">string</a></code>
      is always null-terminated, <code class="computeroutput"><span class="identifier">data</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">c_str</span><span class="special">()</span></code>, and <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> are synonyms. Synonyms bad. Small interfaces
      good.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h3"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.inserting_null_terminated_sequences"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.inserting_null_terminated_sequences">Inserting
      Null Terminated Sequences</a>
    </h4>
<p>
      The <code class="computeroutput"><a class="link" href="../boost/text/v1/string.html" title="Struct string">string</a></code>
      inserting interfaces (<code class="computeroutput"><span class="identifier">insert</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">replace</span><span class="special">()</span></code>) remove explicit null terminators from inserted
      <code class="computeroutput"><a class="link" href="../boost/text/v1/string_view.html" title="Struct string_view">string_views</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/text/v1/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_views</a></code>,
      because leaving them in is almost certainly an error. This can still be accomplished
      by directly writing through the index operator or an iterator, or by inserting
      <code class="computeroutput"><span class="identifier">string_view</span><span class="special">(</span><span class="string">"\0"</span><span class="special">)</span></code>.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h4"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale._classname_alt__boost__text__v1__string___code__phrase_role__identifier__string__phrase___code___classname____classname_alt__boost__text__v1__text___code__phrase_role__identifier__text__phrase___code___classname____classname_alt__boost__text__v1__unencoded_rope___code__phrase_role__identifier__unencoded_rope__phrase___code___classname__and__classname_alt__boost__text__v1__rope___code__phrase_role__identifier__rope__phrase___code___classname__are_implicitly_convertible_from__code__phrase_role__keyword__char__phrase___phrase_role__keyword__const__phrase___phrase_role__special_____phrase___code__"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale._classname_alt__boost__text__v1__string___code__phrase_role__identifier__string__phrase___code___classname____classname_alt__boost__text__v1__text___code__phrase_role__identifier__text__phrase___code___classname____classname_alt__boost__text__v1__unencoded_rope___code__phrase_role__identifier__unencoded_rope__phrase___code___classname__and__classname_alt__boost__text__v1__rope___code__phrase_role__identifier__rope__phrase___code___classname__are_implicitly_convertible_from__code__phrase_role__keyword__char__phrase___phrase_role__keyword__const__phrase___phrase_role__special_____phrase___code__">string,
      text,
      unencoded_rope
      and rope
      Are Implicitly Convertible from <code class="computeroutput"><span class="keyword">char</span>
      <span class="keyword">const</span> <span class="special">*</span></code>.</a>
    </h4>
<p>
      I find that the syntactic overhead of bringing UDLs into scope and then using
      them to be too high in some cases. Aggregate initialization including string-like
      objects is one of those:
    </p>
<div class="table">
<a name="boost_text__proposed_.rationale.t0"></a><p class="title"><b>Table&#160;1.22.&#160;Explicit vs. Implicit Conversion from `char const *`</b></p>
<div class="table-contents"><table class="table" summary="Explicit vs. Implicit Conversion from `char const *`">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Explicit
              </p>
            </th>
<th>
              <p>
                Implicit
              </p>
            </th>
</tr></thead>
<tbody><tr>
<td>
              <p>
</p>
<pre class="programlisting"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="number">3</span><span class="special">&gt;</span> <span class="special">=</span> <span class="special">{{</span> <span class="string">"foo"</span><span class="identifier">_s</span><span class="special">,</span> <span class="string">"bar"</span><span class="identifier">_s</span><span class="special">,</span> <span class="string">"baz"</span><span class="identifier">_s</span> <span class="special">}};</span>
</pre>
<p>
              </p>
            </td>
<td>
              <p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="number">3</span><span class="special">&gt;</span> <span class="special">=</span> <span class="special">{{</span> <span class="string">"foo"</span><span class="special">,</span> <span class="string">"bar"</span><span class="special">,</span> <span class="string">"baz"</span> <span class="special">}};</span>
</pre>
<p>
              </p>
            </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
      I find the implicit-conversion code much more natural.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h5"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.none_of_the_boost_text_string_types_does_formatted_output"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.none_of_the_boost_text_string_types_does_formatted_output">None
      of the Boost.Text String Types Does Formatted Output</a>
    </h4>
<p>
      This is necessary because a single <code class="computeroutput"><span class="keyword">char</span></code>
      is not a code point, and a even single code point does not correspond to a
      single formatted output glyph. This means that the layout/spacing of the output
      is not something Boost.Text can determine. Higher-level code must deal with
      such issues.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h6"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.unicode_algorithm_tailoring"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.unicode_algorithm_tailoring">Unicode
      Algorithm Tailoring</a>
    </h4>
<p>
      The behavior of some of the Unicode algorithms is intended to be tailorable.
      Boost.Text provides customization of some of its Unicode algorithm implementations
      for this purpose. Some possible tailorings are not available.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Grapheme breaks are not tailorable, because they are fundamental to how
          a large part of Boost.Text operates; everyone must have the same sense
          of what a grapheme is for this to work.
        </li>
<li class="listitem">
          Word breaks are tailorable. The tailorings available via Boost.Text's word
          breaking API should be enough handle most of the shortcomings listed in
          the <a href="https://unicode.org/reports/tr29/#Word_Boundary_Rules" target="_top">word
          break notes in Unicode Text Segmention</a>. The shortcomings not covered
          by Boost.Text's API require dictionary lookups (very much out of scope)
          or extra code point properties (for breaking on script boundaries; also
          out of scope).
        </li>
<li class="listitem">
          Sentence breaks are not tailorable, because the suggested tailorings require
          a large amount of context, and possibly dictionary-style lookups.
        </li>
<li class="listitem">
          Line breaks are not tailorable, because all the suggested tailorings involve
          multiple modes of behavior (e.g. for Korean text) or dictionary lookups.
        </li>
<li class="listitem">
          For bidirectional ordering, Unicode lays out certain tailorings it refers
          to as <a href="https://unicode.org/reports/tr9/#Higher-Level_Protocols" target="_top">Higher
          Level Protocols</a>. Boost.Text directly supports HL1 and HL4. HL2
          is unsupported because it frankly doesn't seem very important. HL3 and
          HL5 can be accomplished by manually adding directional formatting characters
          or other desired code points to segments of text. HL6 is completely unsupported,
          because it also seems like a very low-frequency use case.
        </li>
</ul></div>
<h4>
<a name="boost_text__proposed_.rationale.h7"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.boost_text_does_not_use_allocators"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.boost_text_does_not_use_allocators">Boost.Text
      Does Not Use allocators</a>
    </h4>
<p>
      Allocators are too low gain for the cost they impose. How many <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span></code>
      template instantiations in the code bases of the world involve a non-default
      allocator? I would be surprised if it was as high as 1%. Allocators may once
      have served an important function, but in modern C++ are a perfect example
      of not sticking to "Don't pay for what you don't use."
    </p>
<p>
      As a concrete example, consider <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>.
      This is a type whose sole purpose is to manage the allocations and reallocations
      of a heap-allocated array for you. Its interface allows me, via its allocator
      template parameter, to change its behavior to be a stack-allocated array of
      fixed size, but with a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
      interface. This has a large impact on the properties of the type, the <code class="computeroutput"><span class="keyword">noexcept</span></code>-ness of and time complexity of <code class="computeroutput"><span class="identifier">swap</span><span class="special">()</span></code> to
      name just one. I don't consider this to be a feature of the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
      design, but a bug.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2018 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index/s17.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="unicode_copyright_notice.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
